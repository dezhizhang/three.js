<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script type="text/javascript" src="../libs/three.js"></script>
    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
    <style>
    body{
        margin: 0;
        padding: 0;
        overflow: hidden;
    }
    </style>
</head>
<body>
    <div id="box"></div>
    <div id="stats"></div>
    <script type="text/javascript">

        let step = 0;

        function init() {
            let stats = initStats();
            let scene = new THREE.Scene();

            let camera = new THREE.PerspectiveCamera(45,window.innerWidth / window.innerHeight,0.1,10000);
            camera.position.x = -20;
            camera.position.y = 25;
            camera.position.z = 20;
            camera.lookAt(new THREE.Vector3(5, 0, 0));

            let renderer = new THREE.WebGLRenderer();
            renderer.setClearColor(new THREE.Color(0xEEEEEE,1.0));
            renderer.setSize(window.innerWidth,window.innerHeight);
            renderer.shadowMapEnabled = true;

            let planeGeometry = new THREE.PlaneGeometry(60,40,1,1);
            let planeMaterial = new THREE.MeshLambertMaterial({color:0xffffff});
            let plane = new THREE.Mesh(planeGeometry,planeMaterial);
            plane.receiveShadow = true;
            plane.rotation.x = -0.5 * Math.PI;
            plane.position.x = 0;
            plane.position.y = 0;
            plane.position.z = 0;
            scene.add(plane);

            let spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(-40,60,10);
            spotLight.castShadow = true;
            scene.add(spotLight);

    
            let oBox = document.getElementById('box');
            oBox.appendChild(renderer.domElement);
            
            let vertices = [
                 new THREE.Vector3(1, 3, 1),
                new THREE.Vector3(1, 3, -1),
                new THREE.Vector3(1, -1, 1),
                new THREE.Vector3(1, -1, -1),
                new THREE.Vector3(-1, 3, -1),
                new THREE.Vector3(-1, 3, 1),
                new THREE.Vector3(-1, -1, -1),
                new THREE.Vector3(-1, -1, 1)
            ]
            let faces = [
            new THREE.Face3(0, 2, 1),
                new THREE.Face3(2, 3, 1),
                new THREE.Face3(4, 6, 5),
                new THREE.Face3(6, 7, 5),
                new THREE.Face3(4, 5, 1),
                new THREE.Face3(5, 0, 1),
                new THREE.Face3(7, 6, 2),
                new THREE.Face3(6, 3, 2),
                new THREE.Face3(5, 7, 0),
                new THREE.Face3(7, 2, 0),
                new THREE.Face3(1, 3, 4),
                new THREE.Face3(3, 6, 4),
            ]
    
            let geom = new THREE.Geometry();
            geom.vertices = vertices;
            geom.faces = faces;
            geom.computeFaceNormals();

            let materials = [
                new THREE.MeshLambertMaterial({opacity: 0.6, color: 0x44ff44, transparent: true}),
                new THREE.MeshBasicMaterial({color:0x000000,wireframe:true})
            ]
    
    
            var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, materials);
            mesh.children.forEach(function (e) {
                e.castShadow = true
            });
    
            scene.add(mesh);
    
            function addControl(x, y, z) {
                var controls = new function () {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                };
    
                return controls;
            }
    
            var controlPoints = [];
            controlPoints.push(addControl(3, 5, 3));
            controlPoints.push(addControl(3, 5, 0));
            controlPoints.push(addControl(3, 0, 3));
            controlPoints.push(addControl(3, 0, 0));
            controlPoints.push(addControl(0, 5, 0));
            controlPoints.push(addControl(0, 5, 3));
            controlPoints.push(addControl(0, 0, 0));
            controlPoints.push(addControl(0, 0, 3));
    
            var gui = new dat.GUI();
            gui.add(new function () {
                this.clone = function () {
    
                    var clonedGeometry = mesh.children[0].geometry.clone();
                    var materials = [
                        new THREE.MeshLambertMaterial({opacity: 0.6, color: 0xff44ff, transparent: true}),
                        new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true})
    
                    ];
    
                    var mesh2 = THREE.SceneUtils.createMultiMaterialObject(clonedGeometry, materials);
                    mesh2.children.forEach(function (e) {
                        e.castShadow = true
                    });
    
                    mesh2.translateX(5);
                    mesh2.translateZ(5);
                    mesh2.name = "clone";
                    scene.remove(scene.getChildByName("clone"));
                    scene.add(mesh2);
    
    
                }
            }, 'clone');
    
            for (var i = 0; i < 8; i++) {
    
                f1 = gui.addFolder('Vertices ' + (i + 1));
                f1.add(controlPoints[i], 'x', -10, 10);
                f1.add(controlPoints[i], 'y', -10, 10);
                f1.add(controlPoints[i], 'z', -10, 10);
    
            }
    
            render();
    
            function addCube() {
    
            }
    
            function render() {
                stats.update();
    
                var vertices = [];
                for (var i = 0; i < 8; i++) {
                    vertices.push(new THREE.Vector3(controlPoints[i].x, controlPoints[i].y, controlPoints[i].z));
                }
    
                mesh.children.forEach(function (e) {
                    e.geometry.vertices = vertices;
                    e.geometry.verticesNeedUpdate = true;
                    e.geometry.computeFaceNormals();
                });
    
                // render using requestAnimationFrame
                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }
    
            function initStats() {
    
                var stats = new Stats();
    
                stats.setMode(0); // 0: fps, 1: ms
    
                // Align top-left
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';
    
                document.getElementById("stats").appendChild(stats.domElement);
    
                return stats;
            }
        }
        window.onload = init
    </script>
</body>
</html>