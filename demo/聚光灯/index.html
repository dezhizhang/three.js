<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script type="text/javascript" src="../libs/three.js"></script>
    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
    <style>
        body{
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
        <div id="Stats-output">
            </div>
            <!-- Div which will hold the Output -->
            <div id="WebGL-output">
            </div>
            
            <!-- Javascript code that runs our Three.js examples -->
            <script type="text/javascript">
            
                let step = 0;
                function init() {
                    let stopMovingLight = false;
                    
                    let stats = initStats();
                    let scene = new THREE.Scene();

                    let camera = new THREE.PerspectiveCamera(45,window.innerWidth / window.innerHeight,0.1,1000);
                    camera.position.x = -35;
                    camera.position.y = 30;
                    camera.position.z = 25;
                    camera.lookAt(new THREE.Vector3(10,0,0));
                    scene.add(camera);

                    let renderer = new THREE.WebGLRenderer();
                    renderer.setClearColor(new THREE.Color(0xEEEEEE,1.0));
                    renderer.setSize(window.innerWidth,window.innerHeight);
                    renderer.shadowMapEnabled = true;
                    renderer.shadowMapType = THREE.PCFShadowMap;

                    let planeGeometry = new THREE.PlaneGeometry(60,20,1,1);
                    let planeMaterial = new THREE.MeshLambertMaterial({color:0xffffff});
                    let plane = new THREE.Mesh(planeGeometry,planeMaterial);
                    plane.receiveShadow = true;
                    plane.rotation.x = -0.5 * Math.PI;
                    plane.position.x = 15;
                    plane.position.y = 0;
                    scene.add(plane);

                    let cubeGeometry = new THREE.BoxGeometry(4,4,4);
                    let cubeMaterial = new THREE.MeshLambertMaterial({color:0xff3333});
                    let cube = new THREE.Mesh(cubeGeometry,cubeMaterial);
                    cube.castShadow = true;
                    cube.position.x = -4;
                    cube.position.y = 3;
                    cube.position.z = 0;
                    scene.add(cube);

                    let sphereGeometry = new THREE.SphereGeometry(4,20,20);
                    let sphereMaterial = new THREE.MeshLambertMaterial({color:0x7777ff});
                    let sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
                    sphere.position.x = 20;
                    sphere.position.y = 0;
                    sphere.position.z = 2;
                    sphere.castShadow = true;
                    scene.add(sphere);

                    let ambiColor = '#1c1c1c';
                    let ambientLight = new THREE.AmbientLight(ambiColor);
                    scene.add(ambientLight);

                    let spotLight0 = new THREE.SpotLight(0xCCCCCC);
                    spotLight0.position.set(-40,30,-10);
                    spotLight0.lookAt(plane);
                    scene.add(spotLight0);

                    let target = new THREE.Object3D();
                    target.position = new THREE.Vector3(5,0,0);
                    let pointColor = '#fffff';
                    let spotLight = new THREE.SpotLight(pointColor);
                    spotLight.position.set(-40,60,-10);
                    spotLight.castShadow = true;
                    spotLight.shadowCameraNear = 2;
                    spotLight.shadowCameraFar = 200;
                    spotLight.shadowCameraFov = 30;
                    spotLight.target = plane;
                    spotLight.distance = 0;
                    spotLight.angle = 0.4;
                    scene.add(spotLight);
                    


            
            
                    // add a small sphere simulating the pointlight
                    var sphereLight = new THREE.SphereGeometry(0.2);
                    var sphereLightMaterial = new THREE.MeshBasicMaterial({color: 0xac6c25});
                    var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial);
                    sphereLightMesh.castShadow = true;
            
                    sphereLightMesh.position = new THREE.Vector3(3, 20, 3);
                    scene.add(sphereLightMesh);
            
            
                    // add the output of the renderer to the html element
                    document.getElementById("WebGL-output").appendChild(renderer.domElement);
            
                    // call the render function
                    var step = 0;
            
                    // used to determine the switch point for the light animation
                    var invert = 1;
                    var phase = 0;
            
                    var controls = new function () {
                        this.rotationSpeed = 0.03;
                        this.bouncingSpeed = 0.03;
                        this.ambientColor = ambiColor;
                        this.pointColor = pointColor;
                        this.intensity = 1;
                        this.distance = 0;
                        this.exponent = 30;
                        this.angle = 0.1;
                        this.debug = false;
                        this.castShadow = true;
                        this.onlyShadow = false;
                        this.target = "Plane";
                        this.stopMovingLight = false;
            
                    };
            
            
                    render();
            
                    function render() {
                        stats.update();
                        // rotate the cube around its axes
                        cube.rotation.x += controls.rotationSpeed;
                        cube.rotation.y += controls.rotationSpeed;
                        cube.rotation.z += controls.rotationSpeed;
            
                        // bounce the sphere up and down
                        step += controls.bouncingSpeed;
                        sphere.position.x = 20 + ( 10 * (Math.cos(step)));
                        sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));
            
                        // move the light simulation
                        if (!stopMovingLight) {
                            if (phase > 2 * Math.PI) {
                                invert = invert * -1;
                                phase -= 2 * Math.PI;
                            } else {
                                phase += controls.rotationSpeed;
                            }
                            sphereLightMesh.position.z = +(7 * (Math.sin(phase)));
                            sphereLightMesh.position.x = +(14 * (Math.cos(phase)));
                            sphereLightMesh.position.y = 10;
            
                            if (invert < 0) {
                                var pivot = 14;
                                sphereLightMesh.position.x = (invert * (sphereLightMesh.position.x - pivot)) + pivot;
                            }
            
                            spotLight.position.copy(sphereLightMesh.position);
                        }
            
                        // render using requestAnimationFrame
                        requestAnimationFrame(render);
            
            
                        renderer.render(scene, camera);
                    }
            
                    function initStats() {
            
                        var stats = new Stats();
            
                        stats.setMode(0); // 0: fps, 1: ms
            
                        // Align top-left
                        stats.domElement.style.position = 'absolute';
                        stats.domElement.style.left = '0px';
                        stats.domElement.style.top = '0px';
            
                        document.getElementById("Stats-output").appendChild(stats.domElement);
            
                        return stats;
                    }
                }
            
                window.onload = init;
            
            
            </script>
</body>
</html>